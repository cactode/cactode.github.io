---
layout: post
title: Precision Machine Design FPGAs
subtitle: FPGA = FUNdaMENTAL Principle Gizmo Assignments.
image: /img/projects/fpga/thumbnail.jpg
tags: [project, mechanical, software, long term]
---
I can't say that I had the honor of making that acronym - that goes to Prof. Slocum - but I did have the honor of actually designing them.

FPGAs are bi-weekly assignments in [2.70](http://web.mit.edu/2.70/) that involve building a contraption of our choice. The only restraint is that we we demonstrate some fundamental principle of engineering - and, of course, that we do the math.

## FPGA 1: Finicky Preload with Great Applications
Have you ever counter-rotated two nuts to make a locknut? That question was rhetorical - everyone does that. But is it actually effective?

![](/img/projects/fpga/1.jpg)

Our first FPGA was an attempt to quantify the actual strength of these preloaded "locknuts". We first created an analytical model of two nuts held together.

<details><summary>(click to see code)</summary>
<p>
```matlab
%% FPGA 1

%% parameters
E = 200 * 10^9; %steel 200 GPa
l = 1/20 * 0.0254; %lead = 1/20 in
L = 7/32*2 * 0.0254; %length of assemble (m)
u = 0.5; % coefficient of friction
r = 1/8 * 0.0254; %radius of bolt

%% derived parameters
A = (((7/16)/2)^2 *pi - ((1/4)/2)^2 *pi) * 0.0254^2; % m^2 front area of nut

%% Do calculation
f1 = @computeForce;
f2 = @computeTorque;

%% Function
% Put in equations form
function force = computeForce(original, final)
    A = (((7/16)/2)^2 *pi - ((1/4)/2)^2 *pi) * 0.0254^2; % m^2 front area of nut
    strain = ((final - original)/original)/2;
    E = 190 * 10^9;
    stress = strain*E;
    force = stress * A;
end
function torque = computeTorque(preload)
    u = 0.5;
    r = 1/8 * 0.0254;
    torque = preload*sind(75)*u*r;
end
```
</p>
</details>

We then put our tester-gadget into an Instron to see how our predictions lined up with reality. When using spring washers, our predictions were suprisingly accurate (within 22% in the worst trial) - but when directly mashing the nuts together, our model broke down. Our quest to fix this led to us realizing that bolt tensioning is a science within itself!

![](/img/projects/fpga/2.jpg)

## FPGA 2: Figure Pondering Grading of Assignment
Our second FPGA was an attempt to make a bistable switch - but not just any switch. We wanted it to be the _most satisfying switch in existence_. 

![](/img/projects/fpga/3.jpg)

Our bistable switch features a special 2D arrangement of springs that allows it to snap between two positions with hysterises in a predictable fashion. The static behavior of the system was calculated using a potential energy well based solver.

<details><summary>(click to see code)</summary>
<p>
```python
import numpy as np
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
from matplotlib import cm
from matplotlib.ticker import LinearLocator, FormatStrFormatter


# input parameters (all in mm | radians | N/mm)

p2s = 22  # pivot to slider distance
pl = 44  # pivot length
prom = np.pi / 6  # pivot range of motion (total)
lrom = 25  # slider range of motion (total)
ss = 44  # spring seperation
k = 1.3 / 30  # spring constant
srl = 30  # spring resting length
so = 15  # spring pivot seperation
precision = 100  # number of points to evaluate

# equation derived from matlab


def energy(pa, delta):
    """
    equation source:
    pc = [-pl*np.np.cos(pa), pl*np.np.sin(pa)] % pivot attachment point coords

    tpc = [p2s, ss/2 + delta] % top spring attachment coords

    bpc = [p2s, -ss/2 + delta] % bottom spring attachment coords

    tsl = norm(pc - tpc) % top spring length

    bsl = norm(pc - bpc) % bottom spring length

    tse = (tsl - srl)*k % top spring energy

    bse = (bsl - srl)*k % bottom spring energy

    te = tse + bse % total energy

    matlabs symbolic stuff is way easier lol

    delta -> shift in spring origin
    pa -> angle of pivot

    """
    return (k*(srl - (abs(delta - ss/2 + so*np.cos(pa) - pl*np.sin(pa))**2 + abs(p2s + pl*np.cos(pa) + so*np.sin(pa))**2)**(1/2))**2)/2 + (k*(srl - (abs(delta + ss/2 - so*np.cos(pa) - pl*np.sin(pa))**2 + abs(p2s + pl*np.cos(pa) - so*np.sin(pa))**2)**(1/2))**2)/2



# create map of energy


energy_map_func = np.vectorize(energy)

deltas = np.linspace(-lrom / 2, lrom / 2, precision)

pas = np.linspace(-prom / 2, prom / 2, precision)

pas_Y, deltas_X = np.meshgrid(pas, deltas)

energies = energy_map_func(pas_Y, deltas_X)

# map forward stroke
# starting energy


def generate_path(flipped):
    angles_indexes = [energies[0].argmin()]
    if flipped:
        angles_indexes = [energies[energies.shape[0] - 1].argmin()]
    steps = range(1, energies.shape[0])
    if flipped:
        steps = reversed(steps)
    for i in steps:
        c_angle = angles_indexes[-1]
        while (c_angle > 0):
            if energies[i][c_angle] > energies[i][c_angle - 1]:
                c_angle = c_angle - 1
            else:
                break

        while (c_angle < len(energies[i]) - 1):
            if energies[i][c_angle] > energies[i][c_angle + 1]:
                c_angle = c_angle + 1
            else:
                break

        angles_indexes.append(c_angle)

    path_deltas = deltas
    if flipped:
        path_deltas = [i for i in reversed(deltas)]
    path_pas = [pas[i] for i in angles_indexes]

    path_energies = [energies[i][j]
                     for i, j in zip(range(precision), angles_indexes)]
    if flipped:
        path_energies = [energies[i][j] for i, j in zip(
            reversed(range(precision)), angles_indexes)]

    return (path_deltas, path_pas, path_energies)


fig = plt.figure()
ax = fig.gca(projection='3d')

# Plot the surface.
surf = ax.plot_surface(deltas_X, pas_Y, energies, alpha=0.5,
                       cmap=cm.coolwarm, linewidth=0, antialiased=False)

line_forward = ax.plot(*generate_path(False), linewidth=3, label="Forward Crank Path")
line_backward = ax.plot(*generate_path(True), linewidth=3, label="Backwards Crank Path")

# Customize the z axis.
ax.zaxis.set_major_locator(LinearLocator(6))
ax.zaxis.set_major_formatter(FormatStrFormatter('%.01f'))
ax.set_xlabel("Slider Position")
ax.set_ylabel("Crank Angle")
ax.set_zlabel("Elastic Energy Stored")
ax.legend()
# Add a color bar which maps values to colors.
fig.colorbar(surf, shrink=0.5, aspect=5)

plt.show()
```
</p>
</details>

![](/img/projects/fpga/4.png)

This gave us a nice idea of how the switch would move over its range of motion. The final test showed that our model had only 16% error - most of which came from errors in measuring the resting length of our springs.
